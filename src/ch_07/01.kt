package ch_07

fun main() {
    /*
    1. 코틀린에서 사용되는 클래스의 기본 구조

    class 클래스이름 {
        var 변수
        fun 함수() {
            코드
        }
    }

    2. 클래스 코드 작성하기
    클래스 이름 다음에는 클래스의 범위를 지정하는 중괄호가 있어야 함.
    이 중괄호를 스코프라고 하는데 클래스에서 사용했기 때문에 클래스 스코프라고 한다.

    class 클래스 이름 {
    // 클래스 스코프
    }
    '몇몇 예외'는 있지만 대부분의 코드는 클래스 스코프 안에 작성.

    작성된 클래스를 사용하기 위해서는 생성자라고 불리는 함수가 호출되어야 하는데,
    코틀린은 프라이머리와 세컨더리 2개의 생성자를 제공한다.

    1) 프라이머리 생성자
    class Person 프라이머리 생성자() {
    }
    함수에 있는 코드를 실행하려면 함수를 호출해야 함.
    클래스도 마찬가지로 클래스를 사용한다는 것은 곧 클래스라는 이름으로 묶여 있는 코드를 실행하는 것이기 때문에
    함수 형태로 제공되는 생성자를 호출해야지만 클래스가 실행.

    프라이머리 생성자는 마치 클래스의 헤더처럼 사용할 수 있으며 constructor 키워드를 사용해서 정의하는데 조건에 따라 생략 가능
    프라이머리 생성자도 결국 함수이므로 파라미터를 사용할 수 있음.

    class Person constructor(value: String) {}
    생성자에 접근제한자나 다른 옵션이 없다면 키워드 생략 가능

    class Person (value: String) {}
    클래스의 생성자가 호출되면 init 블록의 코드가 실행되고, init 블록에서는 생성자를 통해 넘어온 파라미터에 접근할 수 있음.
 */
    class Person1 constructor(str: String) {
        init {
            println("생성자로부터 전달받은 값은 ${str}입니다.")
        }
    }

    var person1 = Person1("1") // 생성자로부터 전달받은 값은 1입니다.

    /*
    하지만 init 초기화 작업이 필요하지 않다면 init 블럭을 작성하지 않아도 됨.
    대신 파라미터로 전달된 값을 사용하기 위해서는 파라미터 앞에 변수 키워드인 val 을 붙여주면
    클래스 스코프 안에서 사용할 수 있음.
     */

    class Person2(val str: String) {
        fun process() {
            println("생성자로 생성된 변수의 값은 ${str}입니다.")
        }
    }

    var person2 = Person2("2")
    person2.process() // 생성자로 생성된 변수의 값은 2입니다.

    /*
    2) 세컨더리 생성자
    constructor 키워드를 마치 함수처럼 클래스 스코프 안에 직접 작성할 수 있음.
    그리고 다음과 같이 init 블럭을 작성하지 않고 constructor 다음에 괄호를 붙여서 코드를 작성할 수 있음.

    */

    class Person3 {
        constructor(str: String) {
            println("생성자로부터 전달받는 값은 ${str}입니다.")
        }
    }
    /* 세컨더리 생성자는 파라미터의 개수, 또는 파라미터 타입이 다르면(오버로드) 여러 개를 중복해서 만들 수 있음 */

    class Sample {
        constructor(str: String) {
            println("생성자로부터 전달받은 값은 ${str}입니다.")
        }

        constructor(value: Int) {
            println("생성자로부터 전달받은 값은 ${value}입니다.")
        }

        constructor(value1: Int, value2: String) {
            println("생성자로부터 전달받은 값은 ${value1}, ${value2}입니다.")
        }
    }

    val sample = Sample(1, "2") // 생성자로부터 전달받은 값은 1, 2 입니다.

    /*
    3) Default 생성자
    생성자는 작성하지 않을 경우 파라미터가 없는 프라이머리 생성자가 하나 있는 것과 동일.
    */
    class Student { // 생성자를 작성하지 않아도 기본 생성자가 동작.
        init {
            // 기본 생성자가 없더라도 초기화가 필요하면 여기에 코드를 작성.
        }
    }

    /*
    3. 클래스 사용
    클래스의 이름에 괄호를 붙여서 클래스의 생성자를 호출.
    constructor 키워드를 호출하지 않음.

    클래스명()

    아무런 파라미터 없이클래스명에 괄호를 붙여주면 생성자가 호출되면서 init 블럭 안의 코드가 자동으로 실행.
    세컨더리 생성자의 경우 init 블록이 먼저 실행되고 constructor 블록 안의 코드가 실행.



   -

   코틀린에서는 자바보다 클래스를 좀 더 편하게 사용할 수 있음.
   자바의 보일러 플레이트 코드가 삭제되고 필요한 코드들만 작성하면 되도록 바뀜.

     */

    class Car(val color: String)

    // 객체를 생성. 자바에선 new 키워드를 사용했지만, 코틀린에서는 필요가 없음.
    var car = Car("blue")

}